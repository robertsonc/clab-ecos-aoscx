#!/usr/bin/env python3
# Copyright 2024 Aruba Networks / HPE
# Adapted for vrnetlab by community contributors
#
# Aruba Virtual Gateway (VGW) vrnetlab launcher
#
# The VGW OVA ships two VMDK disks (converted to qcow2 at build time):
#   disk1.qcow2 - OS / boot disk (fixed size)
#   disk2.qcow2 - data disk (resizable)
#
# At every boot the VGW expects a CD-ROM ISO containing device identity
# data generated by Aruba Central. In this vrnetlab wrapper the ISO is
# either:
#   1. Supplied by the operator as /user-data.iso (bind-mounted into the
#      container via containerlab topology), or
#   2. Generated at launch from environment variables when no pre-built
#      ISO is present.

import json
import logging
import os
import re
import signal
import subprocess
import sys
import time

import vrnetlab


def handle_SIGCHLD(signal, frame):
    os.waitpid(-1, os.WNOHANG)


def handle_SIGTERM(signal, frame):
    sys.exit(0)


signal.signal(signal.SIGINT, handle_SIGTERM)
signal.signal(signal.SIGTERM, handle_SIGTERM)
signal.signal(signal.SIGCHLD, handle_SIGCHLD)

TRACE_LEVEL_NUM = 9
logging.addLevelName(TRACE_LEVEL_NUM, "TRACE")


def trace(self, message, *args, **kws):
    if self.isEnabledFor(TRACE_LEVEL_NUM):
        self._log(TRACE_LEVEL_NUM, message, args, **kws)


logging.Logger.trace = trace


class VGW_vm(vrnetlab.VM):
    """Aruba Virtual Gateway VM

    Disk layout (from GNS3 appliance definition and HPE docs):
      hda  - disk1.qcow2 (OS)
      hdb  - disk2.qcow2 (data)
      hdc  - user-data.iso (device identity CD-ROM, required every boot)

    QEMU profile (matching the GNS3 aruba-vgw.gns3a):
      RAM   : 4096 MB
      CPU   : host, 3 cores
      NICs  : 4 x e1000  (mgmt, GE0/0/0, GE0/0/1, GE0/0/2)
      Disks : IDE
      KVM   : required
    """

    def __init__(self, hostname, username, password, conn_mode):
        disk_image = "/disk1.qcow2"
        if not os.path.exists(disk_image):
            raise Exception("disk1.qcow2 not found — was the image built correctly?")

        super(VGW_vm, self).__init__(
            username,
            password,
            disk_image=disk_image,
            ram=4096,
            driveif="ide",
            smp="3",
        )
        self.hostname = hostname
        self.conn_mode = conn_mode

        # 4 NICs per GNS3 template: mgmt + 3 data-plane (GE0/0/0-2)
        self.num_nics = 3
        self.nic_type = "e1000"

        # Attach the second hard disk (data partition)
        self._attach_data_disk()

        # Attach the user-data ISO as CD-ROM
        self._attach_userdata_iso()

        # Override SMP to match the GNS3 appliance definition
        self.qemu_args.extend([
            "-smp", "cores=3,threads=1,sockets=1",
        ])

    def _attach_data_disk(self):
        """Add disk2.qcow2 as a second IDE drive (hdb)."""
        disk2 = "/disk2.qcow2"
        if not os.path.exists(disk2):
            self.logger.warning("disk2.qcow2 not found — skipping data disk")
            return

        # Create a qcow2 overlay so the base image stays pristine
        disk2_overlay = "/disk2-overlay.qcow2"
        if not os.path.exists(disk2_overlay):
            subprocess.check_call([
                "qemu-img", "create", "-f", "qcow2",
                "-F", "qcow2", "-b", disk2,
                disk2_overlay,
            ])

        self.qemu_args.extend(["-drive", f"if=ide,file={disk2_overlay}"])
        self.logger.info("Attached data disk: %s", disk2_overlay)

    def _attach_userdata_iso(self):
        """Attach the Aruba Central user-data ISO as a CD-ROM drive.

        If /user-data.iso exists (bind-mounted by operator) it is used
        directly. Otherwise, if VGW_USERDATA_JSON is set, a minimal ISO
        is generated from that JSON at launch time. When neither is
        available the VM boots without an ISO and will present the
        manual provisioning wizard on the console.
        """
        iso_path = "/user-data.iso"

        if not os.path.exists(iso_path):
            iso_path = self._generate_userdata_iso()

        if iso_path and os.path.exists(iso_path):
            self.qemu_args.extend(["-cdrom", iso_path])
            self.logger.info("Attached user-data ISO: %s", iso_path)
        else:
            self.logger.info(
                "No user-data ISO found — VGW will boot into the "
                "provisioning wizard for manual / DHCP configuration"
            )

    def _generate_userdata_iso(self):
        """Build a minimal user-data ISO from environment variables.

        Set VGW_USERDATA_JSON to a JSON string with the device identity
        fields expected by Aruba Central.  The exact schema depends on
        your Central version; a typical payload looks like:

            {
                "serial": "VGW0000001",
                "mac": "00:50:56:00:00:01",
                "customer_id": "...",
                "certificate": "..."
            }

        The JSON is written to /iso_dir/user-data and packed into an
        ISO image using genisoimage.
        """
        userdata_json = os.getenv("VGW_USERDATA_JSON", "")
        if not userdata_json:
            return None

        self.logger.info("Generating user-data ISO from VGW_USERDATA_JSON")

        iso_dir = "/iso_dir"
        os.makedirs(iso_dir, exist_ok=True)

        with open(os.path.join(iso_dir, "user-data"), "w") as f:
            f.write(userdata_json)

        iso_path = "/user-data.iso"
        subprocess.check_call([
            "genisoimage",
            "-l",
            "-o", iso_path,
            "-V", "config-2",
            "-rational-rock",
            "-joliet",
            iso_dir,
        ])
        return iso_path

    # ------------------------------------------------------------------
    # Boot detection
    # ------------------------------------------------------------------

    def bootstrap_spin(self):
        """Monitor boot progress and wait for system ready.

        The VGW console goes through roughly these stages:
          1. BIOS / GRUB boot messages
          2. ArubaOS boot banner
          3. Provisioning wizard  OR  DHCP auto-provision
          4. login: prompt once the system is up

        When a user-data ISO is mounted the device typically
        auto-provisions via zero-touch (DHCP) and eventually presents
        a login prompt. Without the ISO, a provisioning wizard appears
        on the console offering 'vgw-static' and other options.
        """
        if self.spins > 600:
            # 10 minutes timeout — VGW can be slow to boot
            self.logger.warning("Bootstrap timeout — proceeding anyway")
            self.running = True
            return

        (ridx, match, res) = self.tn.expect(
            [
                b"login:",                                        # 0 - system is up
                b"vgw-static",                                    # 1 - provisioning wizard
                b"Hit any key to stop autoboot",                  # 2 - U-Boot / GRUB
                b"ArubaOS",                                       # 3 - boot banner
                b"Virtual Gateway",                               # 4 - VGW identification
                b"Provisioning",                                  # 5 - provisioning in progress
            ],
            1,
        )

        # Log console output for debugging
        if res:
            res_text = res.decode(errors="replace").strip()
            if res_text and len(res_text) > 2:
                self.logger.info("Console: %s", res_text[-500:])

        if ridx == 0:
            # Login prompt — system is booted and ready
            self.logger.info("VGW login prompt detected — system is up")
            self.running = True
            return

        if ridx == 1:
            # Provisioning wizard — no ISO was supplied
            self.logger.info(
                "VGW provisioning wizard detected (vgw-static). "
                "System is waiting for manual configuration."
            )
            self.running = True
            return

        if ridx == 3:
            self.logger.info("ArubaOS boot banner seen")

        if ridx == 4:
            self.logger.info("Virtual Gateway identification seen")

        if ridx == 5:
            self.logger.info("VGW provisioning in progress...")

        # Increment spin counter
        self.spins += 1


class VGW(vrnetlab.VR):
    """Aruba Virtual Gateway vrnetlab wrapper"""

    def __init__(self, hostname, username, password, conn_mode):
        super(VGW, self).__init__(username, password)
        self.vms = [VGW_vm(hostname, username, password, conn_mode)]


if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Aruba VGW vrnetlab launcher")
    parser.add_argument(
        "--hostname", default="vgw", help="VM hostname (default: vgw)"
    )
    parser.add_argument(
        "--username", default="admin", help="Username (default: admin)"
    )
    parser.add_argument(
        "--password", default="admin", help="Password (default: admin)"
    )
    parser.add_argument(
        "--connection-mode",
        default="tc",
        help="Connection mode: tc or bridge (default: tc)",
    )
    parser.add_argument("--trace", action="store_true", help="Enable trace logging")

    args = parser.parse_args()

    LOG_FORMAT = "%(asctime)s: %(module)-10s %(levelname)-8s %(message)s"
    logging.basicConfig(format=LOG_FORMAT)
    logger = logging.getLogger()

    logger.setLevel(logging.DEBUG)
    if args.trace:
        logger.setLevel(TRACE_LEVEL_NUM)

    logger.info("Starting Aruba Virtual Gateway")

    vrnetlab.boot_delay()

    vr = VGW(
        args.hostname,
        args.username,
        args.password,
        args.connection_mode,
    )
    vr.start()
